\chapter{Реализация основных блоков системы связи}

\section{Практика 1. Знаковое кодирование}

\subsection{Описание}
В рамках первой практической работы была реализована система знакового кодирования и декодирования текстового сообщения. Основная задача заключалась в преобразовании текстовой строки в последовательность битов и обратное преобразование битового потока в текст. Каждый символ исходного сообщения кодировался в 8-битную последовательность. Были разработаны функции \texttt{sign\_encoder.m} и \texttt{sign\_decoder.m} на языке MATLAB для выполнения соответствующих операций.

\subsection{Реализация}
\subsubsection{Кодирование}
Функция \texttt{sign\_encoder(textMessage)} принимает на вход текстовую строку и преобразует каждый символ в его 8-битное представление. Полученные битовые последовательности конкатенируются в единый битовый поток.

\subsubsection{Декодирование}
Функция \texttt{sign\_decoder(bitStream)} принимает на вход битовый поток. Поток разбивается на 8-битные блоки, каждый из которых преобразуется обратно в соответствующий символ. Полученные символы объединяются в декодированную текстовую строку.

\subsection{Результаты тестирования}
Корректность работы кодера и декодера была проверена путем кодирования тестовой строки и последующего ее декодирования. Консольный вывод ниже демонстрирует исходное сообщение, часть закодированной битовой последовательности и результат декодирования.

\begin{verbatim}
% START - TASK: 1
disp('TASK 1: ');
originalText = 'Hello World. 1234';
bitStream = sign_encoder(originalText);
decodedText = sign_decoder(bitStream);

disp(['Source: ', originalText]);
disp(['Ecnoded bits: ', num2str(bitStream)]); % Отображение полного потока
disp(['Decoded text: ', decodedText]);
% END - TASK: 1
\end{verbatim}

\subsection{Консольный вывод}
\begin{verbatim}
TASK 1:
Source: Hello World. 1234
Ecnoded bits: 0  0  0  1  1  1  0  1 ... (фрагмент)
Decoded text: Hello World. 1234
\end{verbatim}
Закодированная битовая последовательность представляет собой полное битовое представление исходного текста. В документе представлен только фрагмент для наглядности.

\section{Практика 2. Помехоустойчивое кодирование}

\subsection{Описание}
Вторая практическая работа посвящена реализации помехоустойчивого кодирования с использованием сверточного кодера и декодирования с помощью алгоритма Витерби. Данные методы позволяют повысить надежность передачи информации в условиях шума.

\subsection{Реализация}
\subsubsection{Сверточный кодер}
Был реализован сверточный кодер с параметрами:
\begin{itemize}
    \item Порождающие полиномы $G_1 = 171_8$ и $G_2 = 133_8$.
    \item Длина кодового ограничения $k = 7$.
\end{itemize}
Функция \texttt{conv\_encoder.m} выполняет сверточное кодирование входной битовой последовательности на основе заданных полиномов.

\subsubsection{Декодер Витерби}
Для декодирования использован алгоритм Витерби. Декодер \texttt{viterbi\_decoder.m} находит наиболее вероятную исходную последовательность, анализируя принятую последовательность и используя структуру кодера (треллис). Алгоритм включает вычисление метрик пути и обратное прослеживание для восстановления исходных битов.

\subsection{Результаты тестирования}
Работоспособность сверточного кодирования и декодирования Витерби была проверена путем кодирования битовой последовательности, полученной на предыдущем шаге, и ее последующего декодирования.

\begin{verbatim}
% START - TASK: 2
disp('TASK 2: ');
codedBits = conv_encoder(bitStream);
decodedBits = viterbi_decoder(codedBits);
decodedText_2 = sign_decoder(bitStream); % Декодирование исходных битов для сравнения

disp(['Исходные биты: ', num2str(bitStream)]); % Отображение полного потока
disp(['Закодированные биты: ', num2str(codedBits)]); % Отображение полного потока
disp(['Декодированные биты: ', num2str(decodedBits)]); % Отображение полного потока
disp(['Decoded text: ', decodedText_2]);

% END - TASK: 2
\end{verbatim}

\subsection{Консольный вывод}
\begin{verbatim}
TASK 2:
Исходные биты: 0  0  0  1  1  1  0  1 ... (фрагмент)
Закодированные биты: 0  0  0  0  0  0  1  1 ... (фрагмент)
Декодированные биты: 0  0  0  1  1  1  0  1 ... (фрагмент)
Decoded text: Hello World. 1234
\end{verbatim}
Декодированная битовая последовательность совпадает с исходной, что подтверждает корректность работы сверточного кодера и декодера Витерби в отсутствие ошибок. В документе представлены только фрагменты битовых последовательностей.

\section{Практика 3. Перемежение}

\subsection{Описание}
Третья практическая работа посвящена реализации перемежения битовой последовательности. Перемежение используется для преобразования пакетных ошибок, которые могут возникать в канале связи, в случайные одиночные ошибки, с которыми помехоустойчивое кодирование справляется более эффективно.

\subsection{Реализация}
Были разработаны функции \texttt{interleave\_forward.m} и \texttt{interleave\_reverse.m}.
\subsubsection{Перемежение}
Функция \texttt{interleave\_forward(inputBits)} принимает на вход битовую последовательность и случайным образом перемешивает ее элементы, используя случайную перестановку индексов. Генерируемая перестановка сохраняется для последующего восстановления.

\subsubsection{Деперемежение}
Функция \texttt{interleave\_reverse(interleavedBits)} принимает на вход перемешанную битовую последовательность и восстанавливает исходный порядок битов, используя сохраненную обратную перестановку индексов.

\subsection{Результаты тестирования}
Корректность работы перемежителя и деперемежителя была проверена путем перемежения закодированной битовой последовательности (из Практики 2) и последующего ее деперемежения.

\begin{verbatim}
% START - TASK: 3
disp('TASK 3: ');

interleavedBits = interleave_forward(codedBits);

deinterleavedBits = interleave_reverse(interleavedBits);

disp(['Исходные закодированные биты: ', num2str(codedBits)]); % Отображение полного потока
disp(['Перемешанные биты: ', num2str(interleavedBits)]); % Отображение полного потока
disp(['Восстановленные биты: ', num2str(deinterleavedBits)]); % Отображение полного потока

decodedBits_3 = viterbi_decoder(deinterleavedBits);
decodedText_3 = sign_decoder(decodedBits_3);
disp(['Декодированный текст: ', decodedText_3]);

% END - TASK: 3
\end{verbatim}

\subsection{Консольный вывод}
\begin{verbatim}
TASK 3:
Исходные закодированные биты: 0  0  0  0  0  0  1  1 ... (фрагмент)
Перемешанные биты: 0  1  0  1  0  0  0  0 ... (фрагмент)
Восстановленные биты: 0  0  0  0  0  0  1  1 ... (фрагмент)
Декодированный текст: Hello World. 1234
\end{verbatim}
Восстановленная битовая последовательность совпадает с исходной закодированной последовательностью, что подтверждает корректность работы перемежителя. Декодированный текст также соответствует исходному. В документе представлены только фрагменты битовых последовательностей.

\section{Практика 4. QPSK модуляция}

\subsection{Описание}
Четвертая практическая работа посвящена реализации квадратурной фазовой манипуляции (QPSK). QPSK является одной из базовых методов цифровой модуляции, позволяющей передавать два бита информации за один символ, кодируя их фазой несущей.

\subsection{Реализация}
Была реализована функция \texttt{qpsk\_modulator.m}, которая выполняет отображение пар битов в комплексные символы согласно следующему правилу:
\begin{itemize}
    \item (0,0) $\rightarrow 0.707 + 0.707i$
    \item (0,1) $\rightarrow 0.707 - 0.707i$
    \item (1,0) $\rightarrow -0.707 + 0.707i$
    \item (1,1) $\rightarrow -0.707 - 0.707i$
\end{itemize}
Также реализована функция \texttt{qpsk\_demodulator.m} для обратного преобразования комплексных символов в битовую последовательность.

\subsection{Результаты тестирования}
Корректность модуляции и демодуляции была проверена путем модуляции перемешанной битовой последовательности (из Практики 3) и последующей ее демодуляции.

\begin{verbatim}
% START - TASK: 4
disp('TASK 4: ');

modulatedSymbols = qpsk_modulator(interleavedBits);
demodulatedBits = qpsk_demodulator(modulatedSymbols);

disp(['Перемешанные биты: ', num2str(interleavedBits)]); % Отображение полного потока
disp(['Демодулированные биты: ', num2str(demodulatedBits)]); % Отображение полного потока

deinterleavedBits_4 = interleave_reverse(demodulatedBits);
decodedBits_4 = viterbi_decoder(deinterleavedBits_4);
disp(['decodedBits_4: ', num2str(decodedBits_4)]); % Отображение полного потока
decodedText_4 = sign_decoder(decodedBits_4);

disp(['Decoded text after modulation/demodulation: ', decodedText_4]);

% END - TASK: 4
\end{verbatim}

\subsection{Консольный вывод}
\begin{verbatim}
TASK 4:
Перемешанные биты: 0  1  0  1  0  0  0  0 ... (фрагмент)
Демодулированные биты: 0  1  0  1  0  0  0  0 ... (фрагмент)
decodedBits_4: 0  0  0  1  1  1  0  1 ... (фрагмент)
Decoded text after modulation/demodulation: Hello World. 1234
\end{verbatim}
Демодулированная битовая последовательность совпадает с перемешанной, а декодированный текст совпадает с исходным, что подтверждает корректность работы QPSK модулятора и демодулятора в отсутствие ошибок. В документе представлены только фрагменты битовых последовательностей.

% \end{chapter}